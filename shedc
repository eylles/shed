#!/bin/sh

myname="${0##*/}"

# OldWorkDir=$PWD

# cd "${XDG_CONFIG_HOME}/shed/services"

# result of: id -u $USER
# cuz $UID is not POSIX ¯\_(ツ)_/¯
UserID=$(id -u "$USER")

# dir of the pid files for the current session
GUISessionDir=/run/user/${UserID}/GUISession${GUI_SESSION_PID}

# directory where we are loading the user services to start from
ServicesDir="${XDG_CONFIG_HOME:-~/.config}"/shed/services

# read the contents of the pid file, cat but more "elegant"
read_file() {
  if [ $# -gt 1 ]; then
    prefix=$2
  else
    prefix=""
  fi
  while read -r FileLine
  do
    printf '%s%s\n' "$prefix" "$FileLine"
  done < "$1"
}

progressbar() {
  count=0
  spinSymbol=0
  progressBar=0
  progressBarPrefix="$1"
  if [ -z "$2" ]; then
    totaltime=2
  else
    totaltime="$2"
  fi
  steptime=$(awk -v tt="$totaltime" 'BEGIN {printf "%.2f", tt/20}')

  while [ "$count" -le 20 ]; do
    case "$spinSymbol" in
      0) spin="-" ;;
      1) spin="\\" ;;
      2) spin="|" ;;
      3) spin="/" ;;
    esac
    printf ' %s%3d%s\r' "$progressBarPrefix $spin   [" "$progressBar" "%]"
    sleep "$steptime"
    count=$(( count + 1 ))
    spinSymbol=$(( spinSymbol + 1 ))
    progressBar=$(( progressBar + 5 ))
    [ "$spinSymbol" -gt 3 ] && spinSymbol=0
  done
  printf '  %s%3d%s\r' "$progressBarPrefix    [" "100" "%]"
  sleep 0.1
  printf '\n'
}

pretty_print() {
    awk '
      {
        if (NR==1) {
          printf " ┌"; for(c=0;c<65;c++) printf"─"; printf "┐\n" ;
          printf " │ %63s │\n", $0 ; 
          printf " ├"; for(c=0;c<32;c++) printf"─"; printf "┬";
          for(c=0;c<22;c++) printf"─"; printf "┬";
          for(c=0;c<9;c++) printf"─"; printf "┤\n" ; 
          printf " │ %30s │ %20s │ %7s │\n", "service           ", "date        ", "status ";
          printf " ├"; for(c=0;c<32;c++) printf"─"; printf "┼";
          for(c=0;c<22;c++) printf"─"; printf "┼";
          for(c=0;c<9;c++) printf"─"; printf "┤\n" ; 
          }
        else { printf " │ %30s │ %20s │ %7s │\n", $1, $2, $3 };
      }
      END { printf " └"; for(c=0;c<32;c++) printf"─"; printf "┴";
          for(c=0;c<22;c++) printf"─"; printf "┴";
          for(c=0;c<9;c++) printf"─"; printf "┘\n" ;}
      ' "$1"

}

read_reply() {
  progressbar "retrieving status:"
  if [ -z "$PrettyPrint" ]; then
    read_file "${GUISessionDir}/reply" "  "
  else
    pretty_print "${GUISessionDir}/reply"
  fi
}

readservicename(){
  # Setting 'IFS' tells 'read' where to split the string.
  while IFS='=' read -r key val; do
    # Skip over lines containing comments.
    # (Lines starting with '#').
    [ "${key##\#*}" ] || continue

    # '$key' stores the key.
    # '$val' stores the value.
    if [ "$key" = "NAME" ]; then
    printf '%s\n' "$val"
    fi
  done < "$1"
}

procstat() {
  if [ -z "$1" ] || [ "all" = "$1" ]; then
    for i in "${ServicesDir}"/* ; do
      ServiceFileName="${i##*/}"
        s_name=$(readservicename "$i")
        if [ -f "${GUISessionDir}/${s_name}.pid" ]; then
          s_pid=$(read_file "${GUISessionDir}/${s_name}.pid")
          if kill -0 "$s_pid" 2>/dev/null; then
            s_state="+"
          else
            s_state="?"
          fi
        else
            s_state="-"
        fi
        printf ' [ %s ]  %s\n' "$s_state" "$s_name"
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName="${i##*/}"
      if [ "$ServiceFileName" = "$1" ]; then
        s_name=$(readservicename "$i")
        if [ -f "${GUISessionDir}/${s_name}.pid" ]; then
          s_pid=$(read_file "${GUISessionDir}/${s_name}.pid")
          if kill -0 "$s_pid" 2>/dev/null; then
            s_state="running with pid: ${s_pid}"
          else
            s_state="was started"
          fi
        else
            s_state="not running"
        fi
        printf '  %s\tstatus: %s\n' "$s_name" "$s_state"
      fi
    done
  fi
}

hupprocs() {
  if [ -z "$1" ] || [ "all" = "$1" ]; then
    for i in "${GUISessionDir}"/*.pid ; do
      s_pid=$(read_file "$i")
      # s_name=$(ps -p "$s_pid" -o comm=)
      s_name="${i##*/}"
      printf ' sending hup to %s\t%s\n' "$s_pid" "$s_name"
      if kill -0 "$s_pid" 2>/dev/null; then
        [ -z "$dry_run" ] && kill -HUP "$s_pid"
      fi
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName="${i##*/}"
      if [ "$ServiceFileName" = "$1" ]; then
        s_name=$(readservicename "$i")
        if [ -f "${GUISessionDir}/${s_name}.pid" ]; then
          s_pid=$(read_file "${GUISessionDir}/${s_name}.pid")
          printf ' sending hup to %s\t%s\n' "$s_pid" "$s_name"
          if kill -0 "$s_pid" 2>/dev/null; then
          [ -z "$dry_run" ] && kill -HUP "$s_pid"
          fi
        else
          printf 'service %s not running\n' "$s_name"
        fi
      fi
    done
  fi
}

killchilds() {
  if [ -z "$1" ] || [ "all" = "$1" ]; then
    for i in "${GUISessionDir}"/*.pid ; do
      s_pid=$(read_file "$i")
      # s_name=$(ps -p "$s_pid" -o comm=)
      s_name="${i##*/}"
      printf ' sending term to %s\t%s\n' "$s_pid" "$s_name"
      if kill -0 "$s_pid" 2>/dev/null; then
      [ -z "$dry_run" ] && kill "$s_pid"
      fi
      [ -z "$dry_run" ] && rm -f "$i"
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName="${i##*/}"
      if [ "$ServiceFileName" = "$1" ]; then
        s_name=$(readservicename "$i")
        if [ -f "${GUISessionDir}/${s_name}.pid" ]; then
          s_pid=$(read_file "${GUISessionDir}/${s_name}.pid")
          printf ' sending term to %s\t%s\n' "$s_pid" "$s_name"
          if kill -0 "$s_pid" 2>/dev/null; then
          [ -z "$dry_run" ] && kill "$s_pid"
          fi
          [ -z "$dry_run" ] && rm -f "${GUISessionDir}/${s_name}.pid"
        else
          printf 'service %s not running\n' "$s_name"
        fi
      fi
    done
  fi
}

startchilds() {
  printf 'start %s\n' "$1" > "${GUISessionDir}/socket"
}

kill_session() {
  killchilds "all"
  [ -z "$dry_run" ] && rm -rf "$GUISessionDir"
  [ -z "$dry_run" ] && kill "$GUI_SESSION_PID"
}

show_help() {
  printf 'Usage: %s [options] { hup | start | stop | restart } [service name] | logout \n' "$myname"
  printf '  -n        dry run.\n  -h        show this help.\n'
  printf '  -p        pretty print from reply socket.\n'
  printf '   hup      send hup to the session service(s)\n'
  printf '   stop     send term to the session service(s)\n'
  printf '   start    send request to start the session service(s)\n'
  printf '   restart  send term to the session service(s) and then send request to start the service(s)\n'
  printf '   logout   send term to the session services and the xsession process\n'
  printf '   reload   send term to the session services and reload shed\n'
  printf '   status   shows the status of the desired service'
  printf 'for all services the status is shown with a symbol as follows:\n'
  printf '\t     [ + ] means the service is running\n'
  printf '\t     [ - ] means the service is not running\n'
  printf '\t     [ ? ] means the service was started but the pid was not among the active processes\n'
}

OPTIND=1
while getopts nhp o; do case "${o}" in
  h) help=1 ;;
  n) dry_run=1 ;;
  p) PrettyPrint=1 ;;
  *) help=1 ;;
esac done
shift $(( OPTIND - 1 ))

[ -z "$invalid" ] || { show_help ; exit 1 ;}
[ -z "$help" ] || { show_help ; exit; }
case $1 in
  stop)
    killchilds "$2"
  ;;
  restart)
    killchilds "$2"
    progressbar "restarting service(s)" 1
    startchilds "$2"
    read_reply
  ;;
  hup)
    hupprocs "$2"
  ;;
  status)
    procstat "$2"
  ;;
  start)
    startchilds "$2"
    read_reply
  ;;
  logout)
    kill_session
  ;;
  reload)
    killchilds "all"
    progressbar "reloading shed" 2
    printf 'reload\n' > "${GUISessionDir}/socket"
    read_reply
  ;;
  *) show_help ; exit 1 ;;
esac

# cd "$OldWorkDir"
