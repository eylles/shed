#!/bin/sh

# OldWorkDir=$PWD

# cd "${XDG_CONFIG_HOME}/shed/services"

# dir of the pid files for the current session
GUISessionDir=/tmp/GUISession${GUI_SESSION_PID}

# directory where we are loading the user services to start from
ServicesDir="${XDG_CONFIG_HOME:-~/.config}"/shed/services

# read the contents of the pid file, cat but more "elegant"
readpidfile() {
  while read -r FilePid
  do
    printf '%s\n' "$FilePid"
  done < "$1"
}

readservicename(){
  # Setting 'IFS' tells 'read' where to split the string.
  while IFS='=' read -r key val; do
    # Skip over lines containing comments.
    # (Lines starting with '#').
    [ "${key##\#*}" ] || continue

    # '$key' stores the key.
    # '$val' stores the value.
    if [ "$key" = "NAME" ]; then
    printf '%s\n' "$val"
    fi
  done < "$1"
}

procstat() {
  if [ -z "$1" ] || [ "all" = "$1" ]; then
    for i in "${ServicesDir}"/* ; do
      ServiceFileName=$(basename "$i")
        s_name=$(readservicename "$i")
        if [ -f "${GUISessionDir}/${s_name}.pid" ]; then
          s_pid=$(readpidfile "${GUISessionDir}/${s_name}.pid")
          if kill -0 "$s_pid" 2>/dev/null; then
            s_state="+"
          else
            s_state="?"
          fi
        else
            s_state="-"
        fi
        printf ' [ %s ]  %s\n' "$s_state" "$s_name"
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName=$(basename "$i")
      if [ "$ServiceFileName" = "$1" ]; then
        s_name=$(readservicename "$i")
        if [ -f "${GUISessionDir}/${s_name}.pid" ]; then
          s_pid=$(readpidfile "${GUISessionDir}/${s_name}.pid")
          if kill -0 "$s_pid" 2>/dev/null; then
            s_state="running with pid: ${s_pid}"
          else
            s_state="was started"
          fi
        else
            s_state="not running"
        fi
        printf '  %s\tstatus: %s\n' "$s_name" "$s_state"
      fi
    done
  fi
}

hupprocs() {
  if [ -z "$1" ] || [ "all" = "$1" ]; then
    for i in "${GUISessionDir}"/*.pid ; do
      s_pid=$(readpidfile "$i")
      # s_name=$(ps -p "$s_pid" -o comm=)
      s_name=$(basename "$i")
      printf 'sending hup to %s\t%s\n' "$s_pid" "$s_name"
      if kill -0 "$s_pid" 2>/dev/null; then
        [ -z "$dry_run" ] && kill -HUP "$s_pid"
      fi
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName=$(basename "$i")
      if [ "$ServiceFileName" = "$1" ]; then
        s_name=$(readservicename "$i")
        if [ -f "${GUISessionDir}/${s_name}.pid" ]; then
          s_pid=$(readpidfile "${GUISessionDir}/${s_name}.pid")
          printf 'sending hup to %s\t%s\n' "$s_pid" "$s_name"
          if kill -0 "$s_pid" 2>/dev/null; then
          [ -z "$dry_run" ] && kill -HUP "$s_pid"
          fi
        else
          printf 'service %s not running\n' "$s_name"
        fi
      fi
    done
  fi
}

killchilds() {
  if [ -z "$1" ] || [ "all" = "$1" ]; then
    for i in "${GUISessionDir}"/*.pid ; do
      s_pid=$(readpidfile "$i")
      # s_name=$(ps -p "$s_pid" -o comm=)
      s_name=$(basename "$i")
      printf 'sending term to %s\t%s\n' "$s_pid" "$s_name"
      [ -z "$dry_run" ] && kill "$s_pid"
      [ -z "$dry_run" ] && rm -f "$i"
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName=$(basename "$i")
      if [ "$ServiceFileName" = "$1" ]; then
        s_name=$(readservicename "$i")
        s_pid=$(readpidfile "${GUISessionDir}/${s_name}.pid")
        printf 'sending term to %s\t%s\n' "$s_pid" "$s_name"
        [ -z "$dry_run" ] && kill "$s_pid"
        [ -z "$dry_run" ] && rm -f "${GUISessionDir}/${s_name}.pid"
      fi
    done
  fi
}

startchilds() {
  printf 'start %s\n' "$1" > "${GUISessionDir}/socket"
}

kill_session() {
  for i in "${GUISessionDir}"/*.pid ; do
    s_pid=$(readpidfile "$i")
    # s_name=$(ps -p "$s_pid" -o comm=)
    s_name=$(basename "$i")
    printf 'sending term to %s\t%s\n' "$s_pid" "$s_name"
    [ -z "$dry_run" ] && kill "$s_pid"
    printf 'removing %s\n' "$i"
    [ -z "$dry_run" ] && rm -f "$i"
  done
  [ -z "$dry_run" ] && rm -rf "${GUISessionDir}/socket"
  [ -z "$dry_run" ] && rm -rf "$GUISessionDir"
  [ -z "$dry_run" ] && kill "$GUI_SESSION_PID"
}

show_help() {
  name=$(basename "$0")
  printf 'Usage: %s [options] { hup | kill | start } [service name] | logout \n' "$name"
  printf '  -n        dry run.\n  -h        show this help.\n'
  printf '   hup      send hup to the session children\n'
  printf '   kill     send term to the session children\n'
  printf '   stop     send term to the session children\n'
  printf '   start    send request to start the session children\n'
  printf '   restart  send term to the session children and then send request to start the children\n'
  printf '   logout   send term to the session children and the xsession process\n'
  printf '   reload   send term to the session children and reload shed\n'
  printf '   status   shows the status of the desired service'
  printf 'for all services the status is shown with a symbol as follows:\n'
  printf '\t     [ + ] means the service is running\n'
  printf '\t     [ - ] means the service is not running\n'
  printf '\t     [ ? ] means the service was started but the pid was not among the active processes\n'
}

OPTIND=1
while getopts nh o; do case "${o}" in
  h) help=1 ;;
  n) dry_run=1 ;;
  *) help=1 ;;
esac done
shift $(( OPTIND - 1 ))

[ -z "$invalid" ] || { show_help ; exit 1 ;}
[ -z "$help" ] || { show_help ; exit; }
case $1 in
  kill) killchilds "$2" ;;
  stop) killchilds "$2" ;;
  restart) killchilds "$2"; startchilds "$2" ;;
  hup) hupprocs "$2" ;;
  status) procstat "$2" ;;
  start) startchilds "$2" ;;
  logout) kill_session ;;
  reload) killchilds "all"; printf 'reload\n' > "${GUISessionDir}/socket" ;;
  *) show_help ; exit 1 ;;
esac

# cd "$OldWorkDir"
