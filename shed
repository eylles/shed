#!/bin/sh

# if we reloaded then we set this to 0
SHED_RELOAD=0

GUISessionDir=/tmp/GUISession${GUI_SESSION_PID}
mkdir -p "$GUISessionDir"
: > "${GUISessionDir}/socket"

ServicesDir="${XDG_CONFIG_HOME}/shed/services"
# XsessionPidsDir=/tmp/xsession_pid_${XSESSION}
# mkdir -p "$XsessionPidsDir"

start_services() {
  NAME=""
  EXEC=""
  E_ARGS=""
  if [ "all" = "$1" ]; then
    for i in "${ServicesDir}"/* ; do
      . "$i"
      $EXEC $E_ARGS &
      proc_pid=$!
      printf '%s\n' "$proc_pid" > "${GUISessionDir}/${NAME}.pid"
      NAME=""
      EXEC=""
      E_ARGS=""
    done
  fi
}

daemon_cycle() {
  Action=""
  Argument=""
  # daemon cycle to run until we recieve a reload action in the socket
  until [ "$SHED_RELOAD" = 1 ] ; do
    # wait until a write is done to the socket
    inotifywait -e modify --format %0 "${GUISessionDir}/socket"
    # read the contents of the socket, action and argument
    while read -r SocAct SocArg; do
      Action=$SocAct
      Argument=$SocArg
    done < "${GUISessionDir}/socket"
    # clear socket
    : > "${GUISessionDir}/socket"
    # debug prints
    # printf 'action: %s\n' $Action
    # printf 'argument: %s\n' $Argument
    # decide what to do with the read action and argument
    case "${Action}" in
      reload) SHED_RELOAD=1 ;;
      start) start_services "$Argument" ;;
    esac
  done
}
# start all services on first run
start_services "all"

daemon_cycle

# reload shed
[ -z "$SHED_RELOAD" ] || exec shed
