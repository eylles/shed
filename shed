#!/bin/sh

# if we reloaded then we set this to 0
SHED_RELOAD=0

# dir for the pid files
# GUI_SESSION_PID=$$ must be exported in the xinitrc/xsession file
# to have the pid of the running graphical session
GUISessionDir=/tmp/GUISession${GUI_SESSION_PID}
mkdir -p "$GUISessionDir"
# create the empty socket file
: > "${GUISessionDir}/socket"

# directory where we are loading the user services to start from
ServicesDir="${XDG_CONFIG_HOME:-~/.config}"/shed/services
# XsessionPidsDir=/tmp/xsession_pid_${XSESSION}
# mkdir -p "$XsessionPidsDir"

start_services() {
  NAME=""
  EXEC=""
  E_ARGS=""
  # if all the services should be started
  if [ "all" = "$1" ]; then
    # for every service file in the services dir
    for i in "${ServicesDir}"/* ; do
      # source the file to get the variables: NAME EXEC E_ARGS from the service
      . "$i"
      # run the service command with the arguments
      $EXEC $E_ARGS &
      # catch the pid of the process
      proc_pid=$!
      # write the pid of the process to the pid file
      printf '%s\n' "$proc_pid" > "${GUISessionDir}/${NAME}.pid"
      NAME=""
      EXEC=""
      E_ARGS=""
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName=$(basename "$i")
      if [ "$ServiceFileName" = "$1" ]; then
        # source the file to get the variables: NAME EXEC E_ARGS from the service
        . "$i"
        # run the service command with the arguments
        $EXEC $E_ARGS &
        # catch the pid of the process
        proc_pid=$!
        # write the pid of the process to the pid file
        printf '%s\n' "$proc_pid" > "${GUISessionDir}/${NAME}.pid"
        NAME=""
        EXEC=""
        E_ARGS=""
      fi
    done
  fi
}

daemon_cycle() {
  Action=""
  Argument=""
  # daemon cycle to run until we recieve a reload action in the socket
  until [ "$SHED_RELOAD" = 1 ] ; do
    # wait until a write is done to the socket
    inotifywait -e modify --format %0 "${GUISessionDir}/socket"
    # read the contents of the socket, action and argument
    while read -r SocAct SocArg; do
      Action=$SocAct
      Argument=$SocArg
    done < "${GUISessionDir}/socket"
    # clear socket
    : > "${GUISessionDir}/socket"
    # debug prints
    # printf 'action: %s\n' $Action
    # printf 'argument: %s\n' $Argument
    # decide what to do with the read action and argument
    case "${Action}" in
      reload) SHED_RELOAD=1 ;;
      start) start_services "$Argument" ;;
    esac
  done
}
# start all services on first run
start_services "all"

daemon_cycle

# reload shed
[ -z "$SHED_RELOAD" ] || exec shed
