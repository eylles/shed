#!/bin/sh

prog="${0##*/}"
shed_pid="${$}"

SHED_ENV_EXPORT_LOC=""
SHED_RELOAD=""

# check if GUI_SESSION_PID is set
if [ -z "$GUI_SESSION_PID" ]; then
  # it wasnt set, so we will use the PID of the parent
  export GUI_SESSION_PID=$PPID
fi

# cuz $UID is not POSIX ¯\_(ツ)_/¯
# but it may be defined in the environment
if [ -z "$UID" ]; then
  # result of: id -u $USER
  UserID=$(id -u "$USER")
else
  UserID="$UID"
fi

# define XDG_RUNTIME_DIR if it doesn't exist
if [ -z "${XDG_RUNTIME_DIR}" ]; then
  # test if the usual location is writeable
  if [ -w "/run/user/${UserID}" ]; then
    # we can simply export it now
    export XDG_RUNTIME_DIR="/run/user/${UserID}"
  else
    # welp, gotta define it as something
    export XDG_RUNTIME_DIR=/tmp/"${UserID}"-runtime-dir
    if ! test -d "${XDG_RUNTIME_DIR}"; then
      mkdir "${XDG_RUNTIME_DIR}"
      chmod 0700 "${XDG_RUNTIME_DIR}"
    fi
  fi
fi

# should return shed's cgroup, cgroup is a linux only feature tho
get_shed_cgroup() {
  # so we can just wing it and use /proc/ directly
  sed 's@.*::/@@' /proc/"${shed_pid}"/cgroup
}

# do we got an XDG_SESSION_ID ?
if [ -z "$XDG_SESSION_ID" ]; then
  # okay, since we don't it will be shed's cgroup
  # other kernels like the bsd families, illumos, darwin, etc ought to have
  # something similar-ish or some property that gets assigned to processes and
  # propagated to their children that we can get and use to define an
  # XDG_SESSION_ID, at least i know bsd got the jails system but got no idea if
  # that would be the correct property to use for this, no idea if people in
  # other unices and unix-like os even care about something like shed to begin
  # with as i'd assume they already got something better and is just we linux
  # folk whom are stuck in the obscurantism of systemd...
  XDG_SESSION_ID="$(get_shed_cgroup)"
  export XDG_SESSION_ID
fi

# directory where we are loading the shed specific config
ConfDir="${XDG_CONFIG_HOME:-${HOME}/.config}/shed/conf"
Config="${ConfDir}/shed.rc"

if [ -r "$Config" ]; then
  . "$Config"
fi

if [ -n "$SHED_ENV_EXPORT_LOC" ]; then
  env_export_dir="${SHED_ENV_EXPORT_LOC%/*}"
  if [ ! -d "$env_export_dir" ]; then
    mkdir -p "$env_export_dir"
  fi
  cat << __ENV_EXPORT__ >> "$SHED_ENV_EXPORT_LOC"
export XDG_RUNTIME_DIR="$XDG_RUNTIME_DIR"
export XDG_SESSION_ID="$XDG_SESSION_ID"
export GUI_SESSION_PID="$GUI_SESSION_PID"
__ENV_EXPORT__
fi

# source shed library
. ./libshed.sh

# werether or not the GUISessionDir was present at startup
# 1=true btw
sessdir=0

# shed start file, contains the pid of the shed process
startfile="${GUISessionDir}/shed.started"

# werether shed is a fresh start or a post reload
reloaded=""

# check if the session dir exists
if [ -d "$GUISessionDir" ]; then
  # let the program knows the dir exists
  sessdir=1
else
  # create the session dir if it doesn't exist
  mkdir -p "$GUISessionDir"
fi
# create the socket file if necessary
if [ ! -p "$msg_socket" ]; then
  if [ -f "$msg_socket" ]; then
    rm "$msg_socket"
  fi
  mkfifo -m 600 "$msg_socket"
fi
# create the reply socket file if necessary
# if [ ! -p "$msg_reply" ]; then
#   if [ -f "$msg_reply" ]; then
#     rm "$msg_reply"
#   fi
#   mkfifo -m 600 "$msg_reply"
# fi
# create the empty reply file if necessary
if [ -f "$msg_reply" ]; then
  : > "$msg_reply"
fi

# check if shed is reloading, writing to socket is not possible when starting
# on a fresh session cuz no one is listening to the socket
if [ "$sessdir" = 1 ]; then
  if [ -f "$startfile" ]; then
    # the pid will not change when reloading as we use exec, so if the pid is
    # different then we should not run at all since only one instance should run
    # per session.
    file_pid=$(cat "$startfile")
    if [ "$file_pid" -eq "$shed_pid" ]; then
      reloaded=1
    else
      printf '%s\n' "${prog}: instance with pid ${file_pid} already running!"
      exit 1
    fi
  else
    printf '%s\n' "$shed_pid" > "$startfile"
  fi
else
  printf '%s\n' "$shed_pid" > "$startfile"
fi

# write started for when shedc requests a reload
[ -n "$reloaded" ] && printf '%s\n' "$prog $prog_v started" > "$msg_reply"

# Return type: void
#       Usage: wait_exit
# --------------------------------------------------
# this function does not return output whatsoever
# sleep 1 second while the GUISessionDir exists
wait_exit () {
  while [ -d "$GUISessionDir" ]; do
    sleep 1
  done
}

# Return type: void
#       Usage: daemon_cycle
# --------------------------------------------------
# this function does not return output whatsoever
daemon_cycle() {
  Action=""
  Argument=""
  # daemon cycle to run until we receive a reload action in the socket
  while [ -z "$SHED_RELOAD" ] || [ "$SHED_RELOAD" = 0 ] ; do
    # check that the GUISessionDir exists
    if [ -d "${GUISessionDir}" ]; then
      # wait until a write is done to the socket
      # read the contents of the socket, action and argument
      # drain the named pipe $msg_socket
      SocInput=$(cat "$msg_socket")
      # from the socket, first column separated by space
      Action="${SocInput%% *}"
      # from the socket, second column separated by space
      Argument="${SocInput##* }"
      # debug prints
      # printf 'action: %s\n' $Action
      # printf 'argument: %s\n' $Argument
      # decide what to do with the read action and argument
      case "${Action}" in
        reload) SHED_RELOAD=1 ;;
        start) start_services "$Argument" ;;
        stop)  killprocs "$Argument" ;;
        hup)   hupprocs "$Argument" ;;
        wait-logout)  wait_exit ;;
      esac
    else
      # shed must exit
      SHED_RELOAD=2
    fi
  done
}
# start all services on first run
start_str=""
if [ "$reloaded" = 1 ]; then
  start_str="all"
else
  start_str="firstrun"
fi
start_services "$start_str"

daemon_cycle

# reload shed
[ "$SHED_RELOAD" = 1 ] && exec shed
