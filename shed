#!/bin/sh

prog="${0##*/}"

# if we reloaded then we set this to 0
SHED_RELOAD=0

# check if GUI_SESSION_PID is set
if [ -z "$GUI_SESSION_PID" ]; then
  # it wasnt set, so we will use the PID of the parent
  export GUI_SESSION_PID=$PPID
fi

# result of: id -u $USER
# cuz $UID is not POSIX ¯\_(ツ)_/¯
UserID=$(id -u "$USER")

# dir for the pid files
# GUI_SESSION_PID=$$ must be exported in the xinitrc/xsession file
# to have the pid of the running graphical session
GUISessionDir=/run/user/${UserID}/GUISession${GUI_SESSION_PID}
# create the session dir if it doesn't exist
[ -d "$GUISessionDir" ] || mkdir -p "$GUISessionDir"
# defined as: /run/user/${UserID}/GUISession${GUI_SESSION_PID}/socket
msg_socket="${GUISessionDir}/socket"
# defined as: /run/user/${UserID}/GUISession${GUI_SESSION_PID}/reply
msg_reply="${GUISessionDir}/reply"
# create the socket file if necesary
if [ ! -p "$msg_socket" ]; then
  if [ -f "$msg_socket" ]; then
    rm "$msg_socket"
  fi
  mkfifo -m 600 "$msg_socket"
fi
# create the empty reply file if necesary
if [ -f "$msg_reply" ]; then
  : > "$msg_reply"
fi

# write started for when shedc requests a reload
printf '%s\n' "$prog started" > "$msg_reply"

# directory where we are loading the user services to start from
ServicesDir="${XDG_CONFIG_HOME:-~/.config}"/shed/services

serv_start() {
  # clean up environment
  NAME=""
  EXEC=""
  E_ARGS=""
  DELAY=""
  s_file="$1"
  # source the file to get the variables: NAME EXEC E_ARGS from the service
  . "$s_file"
  # check if service is already running
  if [ -f "${GUISessionDir}/${NAME}.pid" ]; then
    start_date=$(date '+%Y-%m-%d-%H:%M:%S')
    printf '%s\n' "$NAME $start_date running" >> "$msg_reply"
  else
    [ -z "$DELAY" ] || sleep "$DELAY"
    # run the service command with the arguments
    s_run="exec $EXEC $E_ARGS"
    eval "$s_run" &
    # catch the pid of the process
    proc_pid=$!
    # start date
    start_date=$(date '+%Y-%m-%d-%H:%M:%S')
    # write the pid of the process to the pid file
    printf '%s\n' "$proc_pid" > "${GUISessionDir}/${NAME}.pid"
    printf '%s\n' "$NAME $start_date started" >> "$msg_reply"
  fi
}

start_services() {
  # start date
  start_date=$(date '+%Y-%m-%d-%H:%M:%S')
  printf '%s\n' "$start_date starting services" > "$msg_reply"
  # if all the services should be started
  if [ "all" = "$1" ]; then
    # for every service file in the services dir
    for i in "${ServicesDir}"/* ; do
      serv_start "$i" &
    done
  else
    for i in "${ServicesDir}"/* ; do
      ServiceFileName=$(basename "$i")
      if [ "$ServiceFileName" = "$1" ]; then
        serv_start "$i" &
      fi
    done
  fi
}

daemon_cycle() {
  Action=""
  Argument=""
  # daemon cycle to run until we recieve a reload action in the socket
  while [ "$SHED_RELOAD" = 0 ] ; do
    # wait until a write is done to the socket
    # read the contents of the socket, action and argument
    # drain the named pipe $msg_socket
    SocInput=$(cat "$msg_socket")
    # from the socket, first column separated by space
    Action="${SocInput%% *}"
    # from the socket, second column separated by space
    Argument="${SocInput##* }"
    # debug prints
    # printf 'action: %s\n' $Action
    # printf 'argument: %s\n' $Argument
    # decide what to do with the read action and argument
    case "${Action}" in
      reload) SHED_RELOAD=1 ;;
      start) start_services "$Argument" ;;
    esac
  done
}
# start all services on first run
start_services "all"

daemon_cycle

# reload shed
[ "$SHED_RELOAD" = 0 ] || exec shed
